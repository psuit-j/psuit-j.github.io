<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>【面经】 Spring&amp;&amp;Spring Boot | 吴生胜有声</title><meta name="author" content="Psuit-J"><meta name="copyright" content="Psuit-J"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring&amp;&amp;Spring BootSpring框架1、说说你对Spring IOC的理解？1234答:控制反转将对象的创建和管理由程序员反转给spring程序管理Spring反向控制应用程序所需要使用的外部资源 ,类原来自己主动new对象, 变成交给springIoc容器管理,配置好java对象的bean即可Spring控制的资源全部放置在Spring容器中，该容器称为IoC容">
<meta property="og:type" content="article">
<meta property="og:title" content="【面经】 Spring&amp;&amp;Spring Boot">
<meta property="og:url" content="https://psuit-j.github.io/2024/03/11/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&&Spring%20Boot/index.html">
<meta property="og:site_name" content="吴生胜有声">
<meta property="og:description" content="Spring&amp;&amp;Spring BootSpring框架1、说说你对Spring IOC的理解？1234答:控制反转将对象的创建和管理由程序员反转给spring程序管理Spring反向控制应用程序所需要使用的外部资源 ,类原来自己主动new对象, 变成交给springIoc容器管理,配置好java对象的bean即可Spring控制的资源全部放置在Spring容器中，该容器称为IoC容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zenx-miniapp.oss-cn-beijing.aliyuncs.com/front/activity/21494299577800.jpg">
<meta property="article:published_time" content="2024-03-11T08:30:37.000Z">
<meta property="article:modified_time" content="2024-03-11T08:05:25.283Z">
<meta property="article:author" content="Psuit-J">
<meta property="article:tag" content="面经">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zenx-miniapp.oss-cn-beijing.aliyuncs.com/front/activity/21494299577800.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://psuit-j.github.io/2024/03/11/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&amp;&amp;Spring%20Boot/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":200,"languages":{"author":"作者: Psuit-J","link":"链接: ","source":"来源: 吴生胜有声","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【面经】 Spring&&Spring Boot',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-11 16:05:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://zenx-miniapp.oss-cn-beijing.aliyuncs.com/front/activity/21494299577800.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-link"></i><span> 科普</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="吴生胜有声"><span class="site-name">吴生胜有声</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-link"></i><span> 科普</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【面经】 Spring&amp;&amp;Spring Boot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E7%BB%8F/">面经</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="【面经】 Spring&amp;&amp;Spring Boot"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Spring-Spring-Boot"><a href="#Spring-Spring-Boot" class="headerlink" title="Spring&amp;&amp;Spring Boot"></a>Spring&amp;&amp;Spring Boot</h1><h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h3 id="1、说说你对Spring-IOC的理解？"><a href="#1、说说你对Spring-IOC的理解？" class="headerlink" title="1、说说你对Spring IOC的理解？"></a>1、说说你对Spring IOC的理解？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答:控制反转</span><br><span class="line">将对象的创建和管理由程序员反转给spring程序管理</span><br><span class="line">Spring反向控制应用程序所需要使用的外部资源 ,类原来自己主动new对象, 变成交给springIoc容器管理,配置好java对象的bean即可</span><br><span class="line">Spring控制的资源全部放置在Spring容器中，该容器称为IoC容器</span><br></pre></td></tr></table></figure>



<h3 id="2、什么是Spring的依赖注入？"><a href="#2、什么是Spring的依赖注入？" class="headerlink" title="2、什么是Spring的依赖注入？"></a>2、什么是Spring的依赖注入？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">有依赖关系,给成员变量赋值时，对象由ioc容器提供</span><br><span class="line">- 给基本数据类型的成员变量进行DI：我们需要使用@Value注解完成 属性注解、方法注解</span><br><span class="line">- 给引用数据类型的成员变量进行DI：我们需要使用@Autowired ，@Qualifier</span><br></pre></td></tr></table></figure>



<h3 id="3、依赖注入实现方式有哪些？"><a href="#3、依赖注入实现方式有哪些？" class="headerlink" title="3、依赖注入实现方式有哪些？"></a>3、依赖注入实现方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">1、基于属性注入</span><br><span class="line">      最常用的  private A a；</span><br><span class="line">2、基于 setter 方法注入</span><br><span class="line">3、基于构造器注入</span><br><span class="line">   ： 当两个类属于强关联时，我们也可以通过构造器的方式来实现注入，在构造器的方法参数中注入</span><br></pre></td></tr></table></figure>



<h3 id="4、说说什么是Spring-Bean？"><a href="#4、说说什么是Spring-Bean？" class="headerlink" title="4、说说什么是Spring Bean？"></a>4、说说什么是Spring Bean？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答:IOC容器中创建管理的对象，指所有要加入spring容器的java对象 --实体</span><br><span class="line">带以下注解的类的对象将交给ioc容器管理</span><br><span class="line">@Component</span><br><span class="line">@Controller</span><br><span class="line">@Service</span><br><span class="line">@Repository</span><br><span class="line">使用四大注解声明的bean，要想生效，还需要被组件扫描注解@ComponentScan扫描</span><br></pre></td></tr></table></figure>



<h3 id="5、Spring-Bean的作用域有哪些？scope"><a href="#5、Spring-Bean的作用域有哪些？scope" class="headerlink" title="5、Spring Bean的作用域有哪些？scope"></a>5、Spring Bean的作用域有哪些？scope</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">答：通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</span><br><span class="line"></span><br><span class="line">- singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</span><br><span class="line"></span><br><span class="line">- prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</span><br><span class="line"></span><br><span class="line">- request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</span><br><span class="line"></span><br><span class="line">- session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</span><br><span class="line"></span><br><span class="line">- globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</span><br><span class="line"></span><br><span class="line">　　其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</span><br><span class="line"></span><br><span class="line">　　如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&&Spring%20Boot/3172859-20230605214839763-361118377.png"></p>
<h3 id="6、Spring框架中的单例bean（singleton）是线程安全的吗？如果不是如何解决？"><a href="#6、Spring框架中的单例bean（singleton）是线程安全的吗？如果不是如何解决？" class="headerlink" title="6、Spring框架中的单例bean（singleton）是线程安全的吗？如果不是如何解决？"></a>6、Spring框架中的单例bean（singleton）是线程安全的吗？如果不是如何解决？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答 ： 不是</span><br><span class="line">单例是不安全的，会导致属性重复调用。</span><br><span class="line"></span><br><span class="line">1、改为多例的（就是在class上面加一个@Scope(&quot;request)</span><br><span class="line">万一必须要定义一个非静态成员变量时候，则通过注解@Scope(&quot;prototype&quot;)，将其设置为多例模式。</span><br><span class="line">2、是采用ThreadLocal解决线程安全问题</span><br></pre></td></tr></table></figure>



<h3 id="7、简单说说Spring-Bean的生命周期？"><a href="#7、简单说说Spring-Bean的生命周期？" class="headerlink" title="7、简单说说Spring Bean的生命周期？"></a>7、简单说说Spring Bean的生命周期？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br></pre></td></tr></table></figure>
<p><img src="/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&&Spring%20Boot/3172859-20230605214933973-783522962.png"><br>对象实例化 —&gt;   初始化【属性赋值】  —&gt; 完整对象【可以使用】 —-&gt; 容器关闭，销毁对象</p>
<p>具体的我虽然记不住，有些我在开发中使用过【1和3就是实际的应用场景】。<br>我们只需要说出Spring Bean生命周期中的关键点【重点前两个】就可以了，比如：<br>    1、我们可以使用 @PostContructor 注解，声明Bean的初始化方法，可以在Bean创建时执行一些代码<br>        &#x2F;&#x2F;mysql 到 es的数据预加载！！<br>        &#x2F;&#x2F;缓存预热！！！</p>
<pre><code>2、我们也可以使用 @PreDestroy 注解，声明Bean的销毁方法，可以在Bean销毁前执行一些资源释放的代码
</code></pre>
<h3 id="8、使用-Autowired注解自动装配的过程是怎样的？"><a href="#8、使用-Autowired注解自动装配的过程是怎样的？" class="headerlink" title="8、使用@Autowired注解自动装配的过程是怎样的？"></a>8、使用@Autowired注解自动装配的过程是怎样的？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">答 :     </span><br><span class="line">在启动spring IOC时，容器自动装载了一个 AutowiredAnnotationBeanPostProcessor 后置处理器，用于实现<span class="meta">@Autowired</span>注解的功能。</span><br><span class="line">当容器扫描到<span class="meta">@Autowired</span>时，就会在IOC容器自动查找需要的bean,并进行装配。【忽略】</span><br><span class="line">    </span><br><span class="line">举例如下：</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserService userSerivce;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上述代码，通过<span class="meta">@Autowired</span>完成UserService 属性的注入，具体过程如下</span><br><span class="line"><span class="number">1</span>、先根据UserService类型查询容器中的Bean，如果有且存在一个，则直接注入【赋值】给变量userSerivce；</span><br><span class="line"><span class="number">2</span>、如果根据类型匹配到的Bean不止一个，那么此时会使用变量名userSerivce作为Bean的id，根据id进行匹配。如果匹配到，则完成属性注入</span><br><span class="line"><span class="number">3</span>、如果上述两种情况都无法完成注入，那么默认则会抛出异常。</span><br></pre></td></tr></table></figure>



<h3 id="9、说说Spring常用的注解有哪些？"><a href="#9、说说Spring常用的注解有哪些？" class="headerlink" title="9、说说Spring常用的注解有哪些？"></a>9、说说Spring常用的注解有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">控制反转层：bean对象里 【@Component、@Controller、@Service、@Repository】</span><br><span class="line">组件扫描 ： @ComponentScan </span><br><span class="line">依赖注入 ： @Autowired 、@Primary 、 @Qualifier、@Resourse</span><br><span class="line"></span><br><span class="line">@Autowired：用于自动装配依赖对象。</span><br><span class="line">	2. @Component：用于标识一个类为Spring容器的组件，可以自动扫描并注册为Bean。</span><br><span class="line">	3. @Controller：用于标识一个类为MVC控制器。</span><br><span class="line">	4. @Service：用于标识一个类为业务逻辑层（Service）的组件。</span><br><span class="line">	5. @Repository：用于标识一个类为数据访问层（Repository）的组件。</span><br><span class="line">	6. @Configuration：用于标识一个类为配置类，通常与@Bean注解一起使用。</span><br><span class="line">	7. @Bean：用于在配置类中定义一个Bean。</span><br><span class="line">	8. @Qualifier：用于指定具体的Bean名称进行注入。</span><br><span class="line">	9. @Value：用于注入外部配置文件中的值。</span><br><span class="line">	10. @Scope：用于指定Bean的作用域。</span><br><span class="line">	11. @RequestMapping：用于映射HTTP请求到控制器的处理方法。</span><br><span class="line">	12. @PathVariable：用于将URL中的参数绑定到方法参数上。</span><br><span class="line">	13. @RequestParam：用于获取请求参数的值。</span><br><span class="line">	14. @ResponseBody：用于将方法返回值转换为指定的格式（如JSON）并作为响应返回。</span><br><span class="line">	15. @Transactional：用于声明事务的范围。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10、你们项目中的事务是如何处理的？一般事务在三层架构中的哪层进行处理？"><a href="#10、你们项目中的事务是如何处理的？一般事务在三层架构中的哪层进行处理？" class="headerlink" title="10、你们项目中的事务是如何处理的？一般事务在三层架构中的哪层进行处理？"></a>10、你们项目中的事务是如何处理的？一般事务在三层架构中的哪层进行处理？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">事务是一组操作的集合，整体要么一起成功，要么一起失败</span><br><span class="line">我们项目中主要是添加注解来处理事务的，声明式事务</span><br><span class="line">在启动类上加@EnableTransactonalManager</span><br><span class="line">事务加在service层，把@transactional加在实现类上或者接口上都可以</span><br></pre></td></tr></table></figure>



<h3 id="11、Spring事务的隔离级别有哪些？"><a href="#11、Spring事务的隔离级别有哪些？" class="headerlink" title="11、Spring事务的隔离级别有哪些？"></a>11、Spring事务的隔离级别有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">Read Uncommited，读未提交，即一个事务可以读取另一个未提交事务的数据；并发操作会导致脏读</span><br><span class="line">Read Commited，读操作，即一个事务要等到另一个事务提交后才能读取数据；解决脏读问题；并发操作会导致不可重复读</span><br><span class="line">Repeatable Read，重复读，即开始读取数据（事务开启）时，不再允许修改操作；解决不可重复读问题；并发操作会导致幻读（对应insert操作）</span><br><span class="line">Serializable，序列化，最高的事务隔离级别，该级别下，事务串行化顺序执行；避免脏读、不可重复读与幻读；但是该级别效率低下，比较消耗数据库性能，一般不用。</span><br></pre></td></tr></table></figure>



<h3 id="12、说说什么是Spring事务传播行为？"><a href="#12、说说什么是Spring事务传播行为？" class="headerlink" title="12、说说什么是Spring事务传播行为？"></a>12、说说什么是Spring事务传播行为？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答:Spring事务传播行为就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行事务控制</span><br><span class="line"></span><br><span class="line">方法运行的时候，首先会开启一个事务，在A方法当中又调用了B方法， B方法自身也具有事务，那么B方法在运行的时候，到底是加入到A方法的事务当中来，还是B方法在运行的时候新建一个事务？</span><br><span class="line"></span><br><span class="line">通过属性控制事务的传播行为 @Transactional(propagation = &quot;属性&quot;)</span><br><span class="line">属性：</span><br><span class="line">【见下表，关注高亮即可】</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;REQUIRED&#x3D;&#x3D;</td>
<td>【默认值】需要事务，有则加入，无则创建新事务</td>
</tr>
<tr>
<td>&#x3D;&#x3D;REQUIRES_NEW&#x3D;&#x3D;</td>
<td>需要新事务，无论有无，总是创建新事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>支持事务，有则加入，无则在无事务状态中运行</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>不支持事务，在无事务状态下运行,如果当前存在已有事务,则挂起当前事务</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>必须有事务，否则抛异常</td>
</tr>
<tr>
<td>NEVER</td>
<td>必须没事务，否则抛异常</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody></table>
<h3 id="13、Spring事务的传播行为有哪些？"><a href="#13、Spring事务的传播行为有哪些？" class="headerlink" title="13、Spring事务的传播行为有哪些？"></a>13、Spring事务的传播行为有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">见上表</span><br></pre></td></tr></table></figure>



<h3 id="14、简单说说Spring事务的底层实现原理？"><a href="#14、简单说说Spring事务的底层实现原理？" class="headerlink" title="14、简单说说Spring事务的底层实现原理？"></a>14、简单说说Spring事务的底层实现原理？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">Spring事务底层是基于AOP实现的，AOP的底层是基于动态代理！！</span><br><span class="line"></span><br><span class="line">策略设计模式</span><br><span class="line">在使用JdbcTemplate的时候，我们在进行查询的时候我们可以对其传递一个RowMapper对象，而RorMapper是一个接口，我们在使用的时候传递其实是这个接口的实现类，传递不同的实现类，那么得到结果就是不同的，这其实就是策略设计模式。</span><br><span class="line">策略模式（Strategy Pattern）使用不同策略的对象实现不同的行为方式，策略对象的变化导致行为的变化。</span><br></pre></td></tr></table></figure>







<h3 id="15、说说哪些情况下会导致spring事务失效？"><a href="#15、说说哪些情况下会导致spring事务失效？" class="headerlink" title="15、说说哪些情况下会导致spring事务失效？"></a>15、说说哪些情况下会导致spring事务失效？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line"><span class="number">1</span>、数据库引擎不支持事务</span><br><span class="line"><span class="number">2</span>、没有被 Spring 管理</span><br><span class="line"><span class="number">3</span>、方法不是 <span class="keyword">public</span> 的</span><br><span class="line">    <span class="meta">@Transactional</span> 只能用于 <span class="keyword">public</span> 的方法上，否则事务不会失效，如果要用在非 <span class="keyword">public</span> 方法上，可以开启     AspectJ 代理模式</span><br><span class="line"><span class="number">4</span>、不支持事务</span><br><span class="line">    Propagation.NOT_SUPPORTED</span><br><span class="line"><span class="number">5</span>、使用<span class="keyword">try</span> <span class="keyword">catch</span>  ，但不抛异常，事务无法回滚</span><br><span class="line"><span class="number">6</span>、异常类型错误，使用<span class="keyword">try</span> <span class="keyword">catch</span>  ，抛异常错误，默认回滚的是：RuntimeException，如果你想触发其他异常的回     滚，需要在注解上配置一下，如：</span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure>



<h3 id="16、说说什么是AOP？"><a href="#16、说说什么是AOP？" class="headerlink" title="16、说说什么是AOP？"></a>16、说说什么是AOP？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">面向切面编程，它可以在不改动原来代码的基础上对方法进行增强。</span><br><span class="line">我们开发中很多地方都用到了AOP，比如 </span><br><span class="line">	我之前给公司开发的通用日志组件就用到了AOP</span><br><span class="line">	spring的声明式事务就用到了AOP</span><br><span class="line">	springboot的全局异常处理器，即项目中的统一异常处理，就用到了AOP</span><br></pre></td></tr></table></figure>



<h3 id="17、简单说说AOP的底层是基于什么实现的？"><a href="#17、简单说说AOP的底层是基于什么实现的？" class="headerlink" title="17、简单说说AOP的底层是基于什么实现的？"></a>17、简单说说AOP的底层是基于什么实现的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答：AOP的底层使用的动态代理。</span><br><span class="line">动态代理有两种： 基于JDK的、 基于CGLIB的代理</span><br><span class="line">JDK的动态代理是基于接口进行代理的，被代理的对象必须去实现指定的接口。并且JDK的动态代理所产生的代理对象和被代理类是平级的关系。</span><br><span class="line">CGLIB的代理：可以对类直接进行代理，它所产生的代理对象和被代理类之间的关系是继承的关系(不能无中生有,所以要继承被代理的类)</span><br><span class="line">两者本质都是对方法的增强</span><br></pre></td></tr></table></figure>



<h3 id="18、AOP的通知类型有哪些？"><a href="#18、AOP的通知类型有哪些？" class="headerlink" title="18、AOP的通知类型有哪些？"></a>18、AOP的通知类型有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">前置通知(&lt;aop:before&gt;)： 原始方法执行前执行，如果通知中抛出异常，自己仍会执行, 阻止原始方                                   法运行</span><br><span class="line">后置通知(&lt;aop:after&gt;)：  原始方法执行后执行，无论原始方法中是否出现异常，都将执行通知                                       都可</span><br><span class="line">返回后通知(&lt;aop:after-returning&gt;)： 原始方法正常执行完毕并返回结果后执行，如果原始方法中抛出异常，                                    无法执行 成功后</span><br><span class="line">抛出异常后通知(&lt;aop:after-throwing&gt;)： 原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行异常后</span><br><span class="line">环绕通知(&lt;aop:around&gt;)： 在原始方法执行前后均有对应执行，还可以阻止原始方法的执行</span><br><span class="line"></span><br><span class="line">** 环绕通知的注意事项 **：</span><br><span class="line">1、在环绕通知中我们需要去执行我们的原始方法，在进行执行原始方法的时候我们需要使用一个对象去调用原始方法，这个对象ProceedingJoinPoint ，JoinPoint父类,连接点是目标对象类的所有方法,所以这个对象可以获得所有方法相关的信息和参数</span><br><span class="line">2、这个ProceedingJoinPoint这个参数只能是环绕通知方法的第一个参数</span><br><span class="line">3、一般情况下在定义我们这个环绕通知方法的时候，方法一般情况下我们需要定义返回值类型（Object）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="20、说说AOP一般能用来干什么？在你的项目中有用到吗，如何使用的？"><a href="#20、说说AOP一般能用来干什么？在你的项目中有用到吗，如何使用的？" class="headerlink" title="20、说说AOP一般能用来干什么？在你的项目中有用到吗，如何使用的？"></a>20、说说AOP一般能用来干什么？在你的项目中有用到吗，如何使用的？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">方法增强</span><br><span class="line">在我之前的项目中用到了，刚好这部分是我处理的，我做了异步日记记录的功能，这个功能可以异步记录操作我们系统的操作人的信息、执行了哪些操作等</span><br><span class="line">具体实现： </span><br><span class="line">1、自定义一个注解@Log</span><br><span class="line">2、编写日志表，封装数据</span><br><span class="line">3、编写AOP代码实现记录日志的功能：定义一个通知类【@Aspect】，在通知类中实现记录日志的操作，完成代码增强 </span><br><span class="line">4、执行异步多线程，保证在你的项目中加入@Log注解时，主项目不会报错</span><br></pre></td></tr></table></figure>



<h3 id="21、Spring-框架中都用到了哪些设计模式，简单说说？"><a href="#21、Spring-框架中都用到了哪些设计模式，简单说说？" class="headerlink" title="21、Spring 框架中都用到了哪些设计模式，简单说说？"></a>21、Spring 框架中都用到了哪些设计模式，简单说说？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line"></span><br><span class="line">- 单例模式</span><br><span class="line">  保证一个类仅有一个实例，并提供一个访问它的全局访问点。</span><br><span class="line">  spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是是任意的java对象。</span><br><span class="line"></span><br><span class="line">- **适配器模式**</span><br><span class="line">  在Spring的Aop中，使用的Advice（通知）来增强被代理类的功能。Spring实现这一AOP功能的原理就使用代理模式（1、JDK动态代理。2、CGLib字节码生成技术代理。）对类进行方法级别的切面增强，即，生成被代理类的代理类， 并在代理类的方法前，设置拦截器，通过执行拦截器重的内容增强了代理方法的功能，实现的面向切面编程。</span><br><span class="line"></span><br><span class="line">- **工厂方法模式**</span><br><span class="line">  IoC的出现——工厂模式衍化而来 </span><br><span class="line">  一般情况下,应用程序有自己的工厂对象来创建bean.如果将应用程序自己的工厂对象交给Spring管理,那么Spring管理的就不是普通的bean,而是工厂Bean。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="22、知道Spring是如何解决Bean的循环依赖的吗-？"><a href="#22、知道Spring是如何解决Bean的循环依赖的吗-？" class="headerlink" title="22、知道Spring是如何解决Bean的循环依赖的吗 ？"></a>22、知道Spring是如何解决Bean的循环依赖的吗 ？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">找一个中间缓存（三级缓存），Spring 在创建 bean 的时候并不是等它完全完成，而是将创建中的 bean 提前曝光（即加入到 singletonFactories 三级缓存中），当下一个 bean 创建的时候需要依赖此 bean ，则从三级缓存中获取。</span><br><span class="line"></span><br><span class="line">**拓展** 描述一下 Spring 解决循环依赖的过程：</span><br><span class="line"></span><br><span class="line">先创建 A 对象，并将创建出来的 A 对象放到 Spring 的三级缓存中；</span><br><span class="line">此时 A 对象的 b 属性为空，需要填充 b 属性，到缓存中查询 B 对象，没有查到，触发 B 对象的创建流程；</span><br><span class="line">创建 B 对象，并将创建出来的 B 对象放到 Spring 的三级缓存中；</span><br><span class="line">B 对象的 a 属性为空，需要填充 a 属性，随后在缓存中找到 A 对象，完成填充注入；</span><br><span class="line">最后再对 A 对象的 b 属性进行填充，从缓存中顺利拿到 B 对象，完成属性注入，循环依赖到此解决。</span><br></pre></td></tr></table></figure>



<h3 id="23、动态代理的方式有哪些？"><a href="#23、动态代理的方式有哪些？" class="headerlink" title="23、动态代理的方式有哪些？"></a>23、动态代理的方式有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">答：</span><br><span class="line">两种</span><br><span class="line">动态代理有两种： 基于JDK的、 基于CGLIB的代理</span><br><span class="line">JDK的动态代理是基于接口进行代理的，被代理的对象必须去实现指定的接口。并且JDK的动态代理所产生的代理对象和被代理类是平级的关系。</span><br><span class="line">CGLIB的代理：可以对类直接进行代理，它所产生的代理对象和被代理类之间的关系是继承的关系(不能无中生有,所以要继承被代理的类)</span><br><span class="line">两者本质都是对方法的增强</span><br></pre></td></tr></table></figure>



<h3 id="24、FactoryBean-和-BeanFactory的区别？"><a href="#24、FactoryBean-和-BeanFactory的区别？" class="headerlink" title="24、FactoryBean   和 BeanFactory的区别？"></a>24、FactoryBean   和 BeanFactory的区别？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FactoryBean ： 封装单个bean的创建过程</span><br><span class="line">BeanFactory ： Spring容器顶层接口，定义了bean相关的获取操作</span><br></pre></td></tr></table></figure>



<h3 id="25、说说spring和springboot的关系？"><a href="#25、说说spring和springboot的关系？" class="headerlink" title="25、说说spring和springboot的关系？"></a>25、说说spring和springboot的关系？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">springboot中集成了spring和springmvc的组件，</span><br></pre></td></tr></table></figure>





<h3 id="26、Spring-Boot如何实现自动配置？"><a href="#26、Spring-Boot如何实现自动配置？" class="headerlink" title="26、Spring Boot如何实现自动配置？"></a>26、Spring Boot如何实现自动配置？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">依赖于@Conditional配置类</span><br><span class="line">SpringBoot中对@Conditional的引用链如下：</span><br><span class="line"></span><br><span class="line">@SpringBootApplication注解主要包含3个注解：@SpringBootConfiguration 、@EnableAutoConfiguration 、@ComponentScan。</span><br><span class="line">1.SpringBoot启动的时候加载主启动类，通过@EnableAutoConfiguration开启自动配置功能。</span><br><span class="line"></span><br><span class="line">2.@EnableAutoConfiguration利用AutoConfigurationImportSelector给容器中导入一些组件。</span><br><span class="line"></span><br><span class="line">3.通过protected List getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)获取候选的配置和核心方法，扫描所有jar包类路径下&quot;META-INF/spring.factories&quot;，通过@AutoConfigurationPackage自动配置包。</span><br><span class="line"></span><br><span class="line">4.把扫描到的文件包装成Properties对象。</span><br><span class="line"></span><br><span class="line">5.从properties中获取到EnableAutoConfiguration.class类名对应的值，并把他们添加在容器中。</span><br><span class="line"></span><br><span class="line">6.整个过程就是将类路径下&quot;META-INF/spring.factories&quot;里面配置的所有EnableAutoConfiguration的值加入到容器中。</span><br><span class="line"></span><br><span class="line">7.根据@Conditional注解中的条件判断，决定这个配置是否生效。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="27、-EnableXxx注解的作用是什么？你有用过哪些？"><a href="#27、-EnableXxx注解的作用是什么？你有用过哪些？" class="headerlink" title="27、@EnableXxx注解的作用是什么？你有用过哪些？"></a>27、@EnableXxx注解的作用是什么？你有用过哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">开启某个功能</span><br><span class="line">@EnableRetry：开启 Spring 的重试功能；</span><br><span class="line">@EnableScheduling：开启 Spring 的定时功能；</span><br><span class="line">@EnableAsync：开启 Spring 的异步功能；</span><br><span class="line">@EnableAutoConfiguration：开启 Spring 的自动装配功能；</span><br><span class="line"></span><br><span class="line">我用过事务的EnableTransactonalManager</span><br></pre></td></tr></table></figure>



<h3 id="28、Spring-Boot与Spring-Cloud的关系是什么？"><a href="#28、Spring-Boot与Spring-Cloud的关系是什么？" class="headerlink" title="28、Spring Boot与Spring Cloud的关系是什么？"></a>28、Spring Boot与Spring Cloud的关系是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring Cloud是基于Spring Boot实现的</span><br><span class="line">Spring Boot分为单体架构和微服务架构</span><br><span class="line">Spring Cloud是解决微服务架构中出现的各种问题的一套解决方案</span><br></pre></td></tr></table></figure>



<h3 id="29、SpringBoot的常用注解有哪些？"><a href="#29、SpringBoot的常用注解有哪些？" class="headerlink" title="29、SpringBoot的常用注解有哪些？"></a>29、SpringBoot的常用注解有哪些？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用的有@RequestMapping、@Autowired、@Value、@EnableAutoConfiguration等</span><br></pre></td></tr></table></figure>

<h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4><p><strong>常用注解：</strong></p>
<ol>
<li><code>@SpringBootApplication</code>：用于标记主启动类，表示这是一个Spring Boot应用程序的入口点。它包含了<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>三个注解的功能。</li>
<li><code>@RestController</code>：用于标记一个类，表示这是一个RESTful风格的控制器。它组合了<code>@Controller</code>和<code>@ResponseBody</code>注解。</li>
<li><code>@RequestMapping</code>：用于映射HTTP请求到控制器方法。可以用于类级别和方法级别，用于指定URL路径和请求方法。</li>
<li><code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>：用于简化常见的HTTP请求映射，分别对应GET、POST、PUT、DELETE请求。</li>
<li><code>@Autowired</code>：用于自动装配依赖关系，通过类型或名称进行依赖注入。</li>
<li><code>@Value</code>：用于注入配置属性值。</li>
<li><code>@Configuration</code>：用于标记配置类，定义应用程序的配置。</li>
<li><code>@EnableAutoConfiguration</code>：启用自动配置，根据项目的依赖自动配置Spring应用程序。</li>
<li><code>@ComponentScan</code>：指定要扫描的包，自动发现和注册Bean组件。</li>
<li><code>@Conditional</code>：根据特定的条件进行条件化配置。</li>
<li><code>@EnableCaching</code>：启用缓存功能。</li>
<li><code>@EnableAsync</code>：启用异步方法执行。</li>
<li><code>@EnableScheduling</code>：启用定时任务调度。</li>
<li><code>@Transactional</code>：声明事务的注解。</li>
</ol>
<h4 id="30、SpringBoot读取配置文件的方式有哪些？"><a href="#30、SpringBoot读取配置文件的方式有哪些？" class="headerlink" title="30、SpringBoot读取配置文件的方式有哪些？"></a>30、SpringBoot读取配置文件的方式有哪些？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用@ConfigurationProperties注解将配置属性绑定到Java类中。</span><br><span class="line">@Value：用于注入配置属性值。	</span><br><span class="line">Enviroment</span><br></pre></td></tr></table></figure>

<h4 id="拓展：-1"><a href="#拓展：-1" class="headerlink" title="拓展："></a>拓展：</h4><ol>
<li><code>application.properties</code>文件： 在Spring Boot项目的<code>src/main/resources</code>目录下创建名为<code>application.properties</code>的文件，可以在该文件中定义应用程序的配置属性。Spring Boot会自动读取并加载这些属性，供应用程序使用。</li>
<li><code>application.yml</code>文件： 与<code>application.properties</code>类似，<code>application.yml</code>文件也用于定义应用程序的配置属性。它使用了YAML（YAML Ain’t Markup Language）语法，提供了一种更加简洁和可读性高的配置格式。</li>
<li>命令行参数： 通过在命令行中使用<code>--</code>或<code>-D</code>参数的方式，可以覆盖或添加应用程序的配置属性。例如，<code>java -jar myapp.jar --server.port=8081</code>可以指定应用程序的端口号为8081。</li>
<li>环境变量： Spring Boot可以读取环境变量中的配置属性。可以将配置属性以<code>SPRING_APPLICATION_</code>开头的环境变量的形式设置，Spring Boot会自动加载这些属性。</li>
<li>外部配置文件： Spring Boot支持在不同位置的外部配置文件中定义配置属性。可以通过指定<code>spring.config.name</code>和<code>spring.config.location</code>属性来指定外部配置文件的名称和路径。例如，可以使用<code>--spring.config.name=myconfig --spring.config.location=/path/to/config/</code>来指定自定义的配置文件。</li>
<li><code>@ConfigurationProperties</code>注解： 可以使用<code>@ConfigurationProperties</code>注解将配置属性绑定到Java类中。通过在Java类中定义与配置属性对应的字段或方法，Spring Boot会自动将配置文件中的属性值注入到该类中。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/psuit-j">Psuit-J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://psuit-j.github.io/2024/03/11/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&amp;&amp;Spring%20Boot/">https://psuit-j.github.io/2024/03/11/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%20Spring&amp;&amp;Spring%20Boot/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://psuit-j.github.io" target="_blank">吴生胜有声</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E7%BB%8F/">面经</a></div><div class="post_share"><div class="social-share" data-image="https://zenx-miniapp.oss-cn-beijing.aliyuncs.com/front/activity/21494299577800.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/11/%E3%80%90flowable%E3%80%91%E5%88%9D%E8%AF%86flowable/" title="【flowable】 初识flowable"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">【flowable】 初识flowable</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/11/%E3%80%90%E7%A7%91%E6%99%AE%E3%80%91%20%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4/" title="【科普】 项目上线操作步骤"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【科普】 项目上线操作步骤</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://zenx-miniapp.oss-cn-beijing.aliyuncs.com/front/activity/21494299577800.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Psuit-J</div><div class="author-info__description">Don‘t be sad and do your own thing quietly</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/psuit-j" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Spring-Boot"><span class="toc-number">1.</span> <span class="toc-text">Spring&amp;&amp;Spring Boot</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9Spring-IOC%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">1、说说你对Spring IOC的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpring%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">2.0.2.</span> <span class="toc-text">2、什么是Spring的依赖注入？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.3.</span> <span class="toc-text">3、依赖注入实现方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFSpring-Bean%EF%BC%9F"><span class="toc-number">2.0.4.</span> <span class="toc-text">4、说说什么是Spring Bean？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81Spring-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9Fscope"><span class="toc-number">2.0.5.</span> <span class="toc-text">5、Spring Bean的作用域有哪些？scope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%EF%BC%88singleton%EF%BC%89%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.0.6.</span> <span class="toc-text">6、Spring框架中的单例bean（singleton）是线程安全的吗？如果不是如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">2.0.7.</span> <span class="toc-text">7、简单说说Spring Bean的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BD%BF%E7%94%A8-Autowired%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.8.</span> <span class="toc-text">8、使用@Autowired注解自动装配的过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%AF%B4%E8%AF%B4Spring%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.9.</span> <span class="toc-text">9、说说Spring常用的注解有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E4%BD%A0%E4%BB%AC%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%9A%84%EF%BC%9F%E4%B8%80%E8%88%AC%E4%BA%8B%E5%8A%A1%E5%9C%A8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E4%B8%AD%E7%9A%84%E5%93%AA%E5%B1%82%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">2.0.10.</span> <span class="toc-text">10、你们项目中的事务是如何处理的？一般事务在三层架构中的哪层进行处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.11.</span> <span class="toc-text">11、Spring事务的隔离级别有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%EF%BC%9F"><span class="toc-number">2.0.12.</span> <span class="toc-text">12、说说什么是Spring事务传播行为？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.13.</span> <span class="toc-text">13、Spring事务的传播行为有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4Spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">2.0.14.</span> <span class="toc-text">14、简单说说Spring事务的底层实现原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E8%AF%B4%E8%AF%B4%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%AF%BC%E8%87%B4spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">2.0.15.</span> <span class="toc-text">15、说说哪些情况下会导致spring事务失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">2.0.16.</span> <span class="toc-text">16、说说什么是AOP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4AOP%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.17.</span> <span class="toc-text">17、简单说说AOP的底层是基于什么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81AOP%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.18.</span> <span class="toc-text">18、AOP的通知类型有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E8%AF%B4%E8%AF%B4AOP%E4%B8%80%E8%88%AC%E8%83%BD%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%9C%89%E7%94%A8%E5%88%B0%E5%90%97%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">2.0.19.</span> <span class="toc-text">20、说说AOP一般能用来干什么？在你的项目中有用到吗，如何使用的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%EF%BC%9F"><span class="toc-number">2.0.20.</span> <span class="toc-text">21、Spring 框架中都用到了哪些设计模式，简单说说？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E7%9F%A5%E9%81%93Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3Bean%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84%E5%90%97-%EF%BC%9F"><span class="toc-number">2.0.21.</span> <span class="toc-text">22、知道Spring是如何解决Bean的循环依赖的吗 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.22.</span> <span class="toc-text">23、动态代理的方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81FactoryBean-%E5%92%8C-BeanFactory%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.23.</span> <span class="toc-text">24、FactoryBean   和 BeanFactory的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E8%AF%B4%E8%AF%B4spring%E5%92%8Cspringboot%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">2.0.24.</span> <span class="toc-text">25、说说spring和springboot的关系？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81Spring-Boot%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%EF%BC%9F"><span class="toc-number">2.0.25.</span> <span class="toc-text">26、Spring Boot如何实现自动配置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81-EnableXxx%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E6%9C%89%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.26.</span> <span class="toc-text">27、@EnableXxx注解的作用是什么？你有用过哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81Spring-Boot%E4%B8%8ESpring-Cloud%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.0.27.</span> <span class="toc-text">28、Spring Boot与Spring Cloud的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81SpringBoot%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.28.</span> <span class="toc-text">29、SpringBoot的常用注解有哪些？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A"><span class="toc-number">2.0.28.1.</span> <span class="toc-text">拓展：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81SpringBoot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.0.28.2.</span> <span class="toc-text">30、SpringBoot读取配置文件的方式有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A-1"><span class="toc-number">2.0.28.3.</span> <span class="toc-text">拓展：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/%E3%80%90mysql%E3%80%91collection%E6%A0%87%E7%AD%BE%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/" title="【mysql】 collection标签多条件查询">【mysql】 collection标签多条件查询</a><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/%E3%80%90redis%E3%80%91redis%E6%8C%81%E4%B9%85%E5%8C%96/" title="【redis】 redis持久化">【redis】 redis持久化</a><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/%E3%80%90redis%E3%80%91Redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/" title="【redis】 Redis主从架构">【redis】 Redis主从架构</a><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/%E3%80%90%E4%BA%8B%E5%8A%A1%E3%80%91%20%E4%BA%8B%E5%8A%A1/" title="【事务】 事务">【事务】 事务</a><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/11/%E3%80%90%E4%BA%8B%E5%8A%A1%E3%80%91%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" title="【事务】 分布式事务">【事务】 分布式事务</a><time datetime="2024-03-11T08:30:37.000Z" title="发表于 2024-03-11 16:30:37">2024-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Psuit-J</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi,  welcome  to  my  <a target="_blank" rel="noopener" href="https://butterfly.js.org/">  blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>